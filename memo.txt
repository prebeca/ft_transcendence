Postgres:
	.Is a database server
	.stores data to retrieve it later

LINKS:
	Postgres image on dockerhub:
		https://hub.docker.com/_/postgres
	Icons for front-end:
		https://pictogrammers.github.io/@mdi/font/1.1.34/
	ref for authentication:
		https://datatracker.ietf.org/doc/html/rfc6749#section-1.3.4
	42API OAuth explained:
		https://api.intra.42.fr/apidoc/guides/web_application_flow
	TYPEORM SQL METHODS:
		https://orkhan.gitbook.io/typeorm/docs/find-options


Access to db files:
	/var/lib/postgresql/data/base/[...]

PpgAdmin:
	.pgAdmin 4 provides simple but powerful dialogs that you can use to design and create database objects.
	Each dialog contains a series of tabs that you use to describe the object that will be created by the dialog;
	the SQL tab displays the SQL command that the server will execute when creating the object.

NestJs:
	.Framework in js.
	.Uses Express as the default HTTP SERVER framework
	
	Controller with routes
		.app.controller.ts
	Unit tests for controller
		.app.controller.spec.ts
	Root module of the app
		.app.module.ts 
	Basic service with a single method
		.app.service.ts 
	Entry file of the aapp which uses thhe core function Nestacctr to create a Nest application instance.
		.main.ts 

Main.ts includes an async funcion which will bootstrap (launch directly) the app 

A. CONTROLLER
	A controller receive requests for the app
	It has a routing mechanism 

	Return in Controller (rResponse-header and Response-body):
		There is two methods

		I. Using the built-in method, when a request handler returns a JavaScript object or array, it will automatically be serialized to JSON.
		When it returns a JavaScript primitive type (e.g., string, number, boolean), however, Nest will send just the value without attempting to serialize it.
		This makes response handling simple: just return the value, and Nest takes care of the rest.
		Furthermore, the response's status code is always 200 by default, except for POST requests which use 201. 
		We can easily change this behavior by adding the @HttpCode(...) decorator at a handler-level (see Status codes).

		II. We can use the library-specific (e.g., Express) response object, which can be injected using the @Res() decorator in the method handler signature (e.g., findAll(@Res() response)).
		With this approach, you have the ability to use the native response handling methods exposed by that object.
		For example, with Express, you can construct responses using code like response.status(200).send().

	N.B: @[...] is a Decorator ; to create our own : https://docs.nestjs.com/custom-decorators

	Asynchronicity in Controller:
		Every async function has to return a Promise (an object Promise)
		Ex: @Get()
				async findAll(): Promise<any[]> {
				return [];
			}

B. PROVIDER
	Many of Nest Classes are providers (Service, Repositori, Factory, Helper etc.)
	They can be dependant of others
	There is something called Dependency Injection (design Pattern)
	This design pattern means that class needs to call others from external sources rather than creating them

Question : what is the difference between interface and dto ?

C. MODULE 
	Is another type of class with a special decorator aka @Module 
	It uses import and export keyword to allow modules to call Providers from others
	Usefull.

D. MiddleWare
	Is a middleman between client and RouteHandler
	It has access to Requests and Responses, can change them, can cut the connection or call the next one



Questions :

- difference entre un Model et une Entity ? Les deux peuvent etre utilise par typeorm et font la meme chose...
- comment utiliser les Promises correctement ?
- comment utiliser les migrations ? (pour tester les clefs etrangeres et le linkage logique entre les tables (souvent user_id))

Commandes :
- nest g resource `nom_de_lobjet` pour creer directement un dossier et tous les fichiers
	(controller + service + entity + module + spec.ts = suffit ensuite de remplir l'entity pour que typeorm cree la table correspondante)

Resume du back-end:

TypeORM est un utilitaire qui permet de link la DB a l'application NestJs
Il propose plusieurs objet tels que les Repository pour pouvoir effectuer des actions dans la DB sans avoir besoin d ecrire du SQL

Il cree les tables en rapport avec la structure que l'on precise dans objet.entity.ts
Il sait ainsi de quel types sont les donnees stockees dams la DB.

En ce qui concerne les controllers, grossierement, ils mappent un chemin d'acces (URL)
a une action concernant un ou plusieurs objet (insertion, update, deletion, etc)

Les services quant a eux sont les fonctions qui vont modifier eux les objets,
pour l'instant une instance d'un objet et une entree de la DB sont intrinsequeent lies.
Ainsi lorsque l'on modifie un objet il est updater dans la DB.

Les DTO nous permettent de valider ou non les donnes recues par example via POST/ PATCH/ PUT
avant de modifier ou d'inserer un element.

Les modules eux, permettent simplement d'autoriser ou non l'exportation de tout ces fichiers
et de choisir des modules a importer pour le bon fonctionnement du module (une partie d'applciation)

RESPONSE HEADER DE BANANAPONG:

HTTP/1.1 302 Found
X-Powered-By: Express
Access-Control-Allow-Origin: *
Access-Control-Allow-Credentials: true
Location: https://api.intra.42.fr/oauth/authorize?response_type=code&redirect_uri=http%3A%2F%2F%3CSERVER_IP%2FHOSTNAME%3E%3A3000%2Fauth%2F42%2Fcallback&client_id=%3C42_API_UID%3E
Content-Length: 0
Date: Mon, 09 May 2022 12:29:59 GMT
Connection: keep-alive
Keep-Alive: timeout=5

HTTP/2 302 Found
cache-control: no-cache
content-encoding: gzip
content-type: text/html; charset=utf-8
date: Mon, 09 May 2022 12:29:59 GMT
location: https://signin.intra.42.fr/users/sign_in?redirect_to=https%3A%2F%2Fapi.intra.42.fr%2Foauth%2Fauthorize%3Fresponse_type%3Dcode%26redirect_uri%3Dhttp%253A%252F%252F%253CSERVER_IP%252FHOSTNAME%253E%253A3000%252Fauth%252F42%252Fcallback%26client_id%3D%253C42_API_UID%253E
status: 302 Found
vary: Origin,Accept-Encoding
x-content-type-options: nosniff
x-frame-options: SAMEORIGIN
x-rack-cors: preflight-hit; no-origin
x-request-id: 13b92925-634b-450a-8f4a-91f126a88836
x-runtime: 0.006822
x-xss-protection: 1; mode=block
X-Firefox-Spdy: h2

Requests:

GET /auth/42/callback HTTP/1.1
Host: localhost:3000
User-Agent: Mozilla/5.0 (X11; Ubuntu; Linux x86_64; rv:99.0) Gecko/20100101 Firefox/99.0
Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,*/*;q=0.8
Accept-Language: en-US,en;q=0.5
Accept-Encoding: gzip, deflate, br
Connection: keep-alive
Referer: http://localhost:8080/
Upgrade-Insecure-Requests: 1
Sec-Fetch-Dest: document
Sec-Fetch-Mode: navigate
Sec-Fetch-Site: same-site
Sec-Fetch-User: ?1
Pragma: no-cache
Cache-Control: no-cache

GET /oauth/authorize?response_type=code&redirect_uri=http%3A%2F%2F%3CSERVER_IP%2FHOSTNAME%3E%3A3000%2Fauth%2F42%2Fcallback&client_id=%3C42_API_UID%3E HTTP/2
Host: api.intra.42.fr
User-Agent: Mozilla/5.0 (X11; Ubuntu; Linux x86_64; rv:99.0) Gecko/20100101 Firefox/99.0
Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,*/*;q=0.8
Accept-Language: en-US,en;q=0.5
Accept-Encoding: gzip, deflate, br
Referer: http://localhost:8080/
Connection: keep-alive
Cookie: _intra_42_session_production=a9e92cf2b2a3b4033c40f1c9020a45a9; _ga_BJ34XNRJCV=GS1.1.1652098255.1.0.1652098255.0; _ga=GA1.1.2002355467.1652098256
Upgrade-Insecure-Requests: 1
Sec-Fetch-Dest: document
Sec-Fetch-Mode: navigate
Sec-Fetch-Site: cross-site
Sec-Fetch-User: ?1
Pragma: no-cache
Cache-Control: no-cache